<!doctype html><html class="theme-next mist use-motion"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"><link href="//koala.ink/lib/google-fonts/fonts.css" rel="stylesheet" type="text/css"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css"><meta name="keywords" content="JS,jquery,plugin,zepto,"><link rel="alternate" href="/atom.xml" title="KoalaInk" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.0.1"><meta name="description" content="最近一个多月有点偷懒，好久没更博了，一直没有时间做个总结。今天就先对先前写jQuery/Zepto的插件做个总结，整理出一份模板，以供以后使用。确切的说应该是两份模板，一份jQuery，一份Zepto，但是这两者间差异不大，只是一些细小的区别罢了。好了，不说废话了，切入正题。  
在插件开发过程中，为了避免文件合并后代码之间的相互影响，所以每个插件都应该写在自己的一个命名空间内，在自己的命名空间中"><meta property="og:type" content="article"><meta property="og:title" content="jQuery/Zepto 插件模板"><meta property="og:url" content="http://koala.ink/posts/d92be856/index.html"><meta property="og:site_name" content="KoalaInk"><meta property="og:description" content="最近一个多月有点偷懒，好久没更博了，一直没有时间做个总结。今天就先对先前写jQuery/Zepto的插件做个总结，整理出一份模板，以供以后使用。确切的说应该是两份模板，一份jQuery，一份Zepto，但是这两者间差异不大，只是一些细小的区别罢了。好了，不说废话了，切入正题。  
在插件开发过程中，为了避免文件合并后代码之间的相互影响，所以每个插件都应该写在自己的一个命名空间内，在自己的命名空间中"><meta property="og:image" content="http://koala.ink/posts_assets/jquery_zepto_plugins_tpl/extend.png"><meta property="og:updated_time" content="2018-05-02T11:21:08.099Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="jQuery/Zepto 插件模板"><meta name="twitter:description" content="最近一个多月有点偷懒，好久没更博了，一直没有时间做个总结。今天就先对先前写jQuery/Zepto的插件做个总结，整理出一份模板，以供以后使用。确切的说应该是两份模板，一份jQuery，一份Zepto，但是这两者间差异不大，只是一些细小的区别罢了。好了，不说废话了，切入正题。  
在插件开发过程中，为了避免文件合并后代码之间的相互影响，所以每个插件都应该写在自己的一个命名空间内，在自己的命名空间中"><meta name="twitter:image" content="http://koala.ink/posts_assets/jquery_zepto_plugins_tpl/extend.png"><script type="text/javascript" id="hexo.configuration">var NexT=window.NexT||{},CONFIG={scheme:"Mist",sidebar:{position:"left",display:"post"},fancybox:!0,motion:!0,duoshuo:{userId:0,author:"Author"}}</script><link rel="canonical" href="http://koala.ink/posts/d92be856/"><title> jQuery/Zepto 插件模板 | KoalaInk</title><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-1951963209134581",enable_page_level_ads:!0})</script></head><body itemscope itemtype="http://schema.org/WebPage" lang="en"><script>!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-85041097-1","auto"),ga("send","pageview")</script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="//hm.baidu.com/hm.js?2ae34fe5bc74dabbd220968d235776a5";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><div style="display:none"><script src="http://s95.cnzz.com/z_stat.php?id=1260520941&web_id=1260520941" language="JavaScript"></script></div><div class="container one-collumn sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">KoalaInk</span><span class="logo-line-after"><i></i></span></a></div><p class="site-subtitle">Internet King —— Koala</p></div><div class="site-nav-toggle"> <button><span class="btn-bar"></span><span class="btn-bar"></span><span class="btn-bar"></span></button></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br> Home</a></li><li class="menu-item menu-item-categories"><a href="/categories" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br> Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br> Archives</a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br> Tags</a></li><li class="menu-item menu-item-about"><a href="/about" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br> About</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br> Search</a></li></ul><div class="site-search"><div class="popup"><span class="search-icon fa fa-search"></span> <input type="text" id="local-search-input"><div id="local-search-result"></div> <span class="popup-btn-close">close</span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><header class="post-header"><h1 class="post-title" itemprop="name headline"> jQuery/Zepto 插件模板</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">Posted on</span> <time itemprop="dateCreated" datetime="2016-01-07T14:44:33+08:00" content="2016-01-07">2016-01-07</time></span> <span class="post-category">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/WEB/" itemprop="url" rel="index"><span itemprop="name">WEB</span></a></span> , <span itemprop="about" itemscope itemtype="https://schema.org/Thing"><a href="/categories/WEB/JS/" itemprop="url" rel="index"><span itemprop="name">JS</span></a></span></span> <span id="/posts/d92be856/" class="leancloud_visitors" data-flag-title="jQuery/Zepto 插件模板">&nbsp; | &nbsp;<span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">visitors&nbsp;</span><span class="leancloud-visitors-count"></span></span></div><div class="post-banner"></div></header><div class="post-body" itemprop="articleBody"><p>最近一个多月有点偷懒，好久没更博了，一直没有时间做个总结。今天就先对先前写jQuery/Zepto的插件做个总结，整理出一份模板，以供以后使用。确切的说应该是两份模板，一份jQuery，一份Zepto，但是这两者间差异不大，只是一些细小的区别罢了。好了，不说废话了，切入正题。</p><p>在插件开发过程中，为了避免文件合并后代码之间的相互影响，所以每个插件都应该写在自己的一个命名空间内，在自己的命名空间中运行。</p><figure class="highlight js"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// code your plugn ...</span></div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure><a id="more"></a><p>如上使用立即执行的匿名函数包裹整个插件，这样插件就能拥有独立的命名空间而不受其他代码的影响，当然也不会影响其他的代码。在一些代码中，为了避免对 $ 使用的混乱，所以最好在自己插件的命名空间中设定好固定的$ ，所以改成如下</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// code your plugn ...</span></div><div class="line"></div><div class="line">&#125;)( jQuery );</div></pre></td></tr></table></figure><p>这样就指定了$ 所代表的是jQuery ，避免了一些不必要的麻烦，当然，如果你使用的是Zepto开发插件，那么就将最后面的jQuery改成Zepto传给$ 就可以了。将这段代码保存为plugn.js 文件。之后就可以开始在这个命名空间内写自己的插件了。</p><p>定义好命名空间之后，就是将插件函数扩展到 jQuery.fn ，在jQuery中， jQuery.fn = jQuery.prototype， 所以只要将你的插件函数扩展到jQuery.fn 中，那么所有的jQuery对象都能够调用到这个函数。jQuery提供了扩展jQuery.fn 的方法，是 jQuery.fn.extend(object) ，这个方法将object对象扩展到jQuery.fn (也就是jQuery.prototype )中，如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  $.fn.extend(&#123;</div><div class="line">    <span class="attr">plugn1</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.html(<span class="string">'&lt;h1&gt;Hello in plugn1&lt;/h1&gt;'</span>);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">plugn2</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">this</span>.html(<span class="string">'&lt;h1&gt;Hello in plugn2&lt;/h1&gt;'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">&#125;)( jQuery );</div></pre></td></tr></table></figure><p>这样在调用的时候就很简单，形式如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-1.11.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/plugn.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  $(<span class="string">"#test"</span>).plugn1();  <span class="comment">// &lt;h1&gt;Hello in plugn1&lt;/h1&gt;</span></div><div class="line">  <span class="comment">// $("#test").plugn2();  // &lt;h1&gt;Hello in plugn2&lt;/h1&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>这里有必要提一下jQuery实现的extend函数，也就是jQuery.extend() 这个函数，这个函数形式如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Objectj jQuery.extend(dest,src1[,src2,src3...])</div></pre></td></tr></table></figure><p>第一个参数为被扩展的目标源对象(dest)，这个函数会将之后的所有对象(src1[,src2…])扩展合并到dest中，函数返回扩展后的dest对象。可见这个函数修改了dest对象的结构，所以如果不希望改变dest对象的结构，也可以这样调用 res = $.extend({},src1[,src2,src3…]) 。</p><p>这个函数的另一种形式是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Objectj jQuery.extend(boolean,dest,src1[,src2,src3...])</div></pre></td></tr></table></figure><p>这里的第一个参数是boolean型变量，代表是否进行深度拷贝，之后的几个参数如上一个形式中提到的一样，这里就不再重复。所谓的深度拷贝，就是当对象中还嵌套对象时，会继续合并扩展嵌套的对象，而不是单纯的替换。如下举例说明：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> result=$.extend( <span class="literal">true</span>, &#123;&#125;,</div><div class="line">  &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">location</span>: &#123;<span class="attr">city</span>: <span class="string">"Boston"</span>,<span class="attr">county</span>:<span class="string">"USA"</span>&#125; &#125;,</div><div class="line">  &#123; <span class="attr">last</span>: <span class="string">"Resig"</span>, <span class="attr">location</span>: &#123;<span class="attr">state</span>: <span class="string">"MA"</span>,<span class="attr">county</span>:<span class="string">"China"</span>&#125; &#125;);</div></pre></td></tr></table></figure><p>运行的结果result值如下：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">result = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">last</span>: <span class="string">"Resig"</span>, <span class="attr">location</span>: &#123; <span class="attr">city</span>: <span class="string">"Boston"</span>, <span class="attr">state</span>: <span class="string">"MA"</span>, <span class="attr">county</span>: <span class="string">"China"</span> &#125; &#125;</div></pre></td></tr></table></figure><p>如果将$.extend 的第一个参数改为false ，那么运行的结果如下所示：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">result = &#123; <span class="attr">name</span>: <span class="string">"John"</span>, <span class="attr">last</span>: <span class="string">"Resig"</span>, <span class="attr">location</span>: &#123; <span class="attr">state</span>: <span class="string">"MA"</span>, <span class="attr">county</span>: <span class="string">"China"</span> &#125; &#125;</div></pre></td></tr></table></figure><p>extend函数还有另外一个形式，就是</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">Objectj jQuery.extend(src)</div></pre></td></tr></table></figure><p>这里就是当参数只有一个的时候，那么jQuery.extend(src) 就是将src扩展到jQuery中。因此 jQuery.extend(object)也可以扩展jQuery，但是扩展的函数调用形式不再是 $(…).myFunc() ，而是 $.myFunc() ，因为这里是扩展到jQuery类全局，相当于是添加jQuery类的方法，属于类级别插件；而$.fn.extend扩展到jQuery.prototype中，是扩展到jQuery的对象原型中，所以每个jQuery对象都能调用到这个函数，属于对象级别的插件。这样说比较抽象，写个demo对比一下</p><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">jQuery</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  jQuery.fn = jQuery.prototype = &#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 这里与使用 jQuery.fn.extend(objPlugn) 等效</div><div class="line">   * @type &#123;Function&#125;</div><div class="line">   */</div><div class="line">  jQuery.fn.objPlugn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"objPlugn"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 这里与使用 jQuery.extend(funcPlugn) 等效</div><div class="line">   * @type &#123;Function&#125;</div><div class="line">   */</div><div class="line">  jQuery.funcPlugn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"funcPlugn"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 这里的 jq 实例即我们使用的 $(...)</div><div class="line">   * @type &#123;jQuery&#125;</div><div class="line">   */</div><div class="line">  <span class="keyword">var</span> jq = <span class="keyword">new</span> jQuery();</div><div class="line"></div><div class="line">  jq.objPlugn();      <span class="comment">// objPlugn</span></div><div class="line">  <span class="comment">// jq.funcPlugn();    // 报错 TypeError: jq.funcPlugn is not a function</span></div><div class="line">  jQuery.funcPlugn();    <span class="comment">// funcPlugn</span></div><div class="line"></div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>因此使用$.extend 与使用$.fn.extend 扩展的jQuery插件还是有区别的。</p><p>这里我们可以查看jQuery的源码</p><p><img src="/posts_assets/jquery_zepto_plugins_tpl/extend.png" alt="jQuery.extend"></p><p>jQuery.extend 函数实现</p><p>图中的第一行我们就能看到，$.extend 与$.fn.extend 这两个函数的实现其实是一样的，而之所以会有刚才说的那些区别，原因就在代码中的197行：target = this; 这一句。在这个if 分支内，就表示传入的src 只有一个的情况，那么就将扩展源对象设置为this，对this进行扩展。当调用extend的上下文环境不同，要扩展的目标源对象就不同，当使用$.extend扩展插件，this指向的是jQuery；而使用$.fn.extend的时候，this指向的是$.fn，即$.prototype。所以要搞清楚$.extend(obj) 与$.fn.extend(obj) 所扩展的对象不同，调用的形式也不同。</p><p>回到刚才说的$.fn.extend() ，这里我们将我们的插件扩展到$.fn 中，以便所有的jQuery对象能够调用，调用形式为$(…).myPlugn() ，如上面在index.html 文件中的$(“#test”).plugn1(); 。</p><p>在使用jQuery对象函数的时候，往往能够链式调用，这点是jQuery一个很大的优点，所以为了使我们开发的插件也能够这样链式操作，我们应该在我们写的插件函数中将自身return回来，把plugn.js文件改成如下形式：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * 如之前说,这里与使用如下形式无异</div><div class="line">   * $.fn.extend(&#123;</div><div class="line">   *     myPlugn : function()&#123;</div><div class="line">   *       // ...</div><div class="line">   *     &#125;</div><div class="line">   * &#125;)</div><div class="line">   * @return &#123;[type]&#125; [description]</div><div class="line">   */</div><div class="line">  $.fn.myPlugn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">      $<span class="keyword">this</span>.html(<span class="string">'&lt;h1&gt;Hello World&lt;/h1&gt;'</span>);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;)( jQuery );</div></pre></td></tr></table></figure><p>这里对this还执行了一次each，是为了支持如果jQuery选择器选中了多个元素，那么可以对选中每个元素都执行到我们插件想要做的事。将index.html代码改为如下</p><figure class="highlight html"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-1.11.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/plugn.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  $(<span class="string">".test"</span>).myPlugn().css(&#123;<span class="attr">color</span>: <span class="string">'#f00'</span>&#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><p>注意此时的jQuery选择器选中了所有class=”test” 的元素，然后执行myPlugn() ，之后还将选中元素的 css 样式修改了，可见，现在已经可以支持链式操作，并且能对选中的jQuery元素都分别进行myPlugn() 操作。到现在为止，已经可以开始开发自己的jQuery小插件了。但是我们在开发过程中，往往希望能够将插件封装起来，这样可以反复的调用，并且操作简单，易于维护。所以我们先假定已经写好了一个MyPlugn的类，我们先修改一下plugn.js文件</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 将 plugn 扩展到 $.fn</div><div class="line">     * @author   dhb(dai_huibin@126.com)</div><div class="line">     * @date     2015-12-23</div><div class="line">     * @datetime 2015-12-23T11:20:43+0800</div><div class="line">     * @param    &#123;object|string&#125;    options    setting options</div><div class="line">     * @param    &#123;array&#125;            paramArray 调用参数</div><div class="line">     * @return   &#123;object&#125;            return self</div><div class="line">     */</div><div class="line">  $.fn.myPlugn = <span class="function"><span class="keyword">function</span>(<span class="params">options, paramArray</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 我们在首次调用myPlugn的时候，实例化一个 MyPlugn 对象，并且将这个实例缓存在$(this).data(myPlugn)中</div><div class="line">       * 这样下次再调用myPlugn的时候，就不需要再实例化，只需要从$(this).data(myPlugn)中取出之前的实例进行操作即可</div><div class="line">       */</div><div class="line">      <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</div><div class="line">        instance = $<span class="keyword">this</span>.data($.fn.myPlugn.info.name);</div><div class="line"></div><div class="line">      <span class="comment">// 这里判断，如果已经存在instance，则表示已实例化过，就无需再实例化MyPlugn对象了</span></div><div class="line">      <span class="keyword">if</span>( !instance )&#123;</div><div class="line">        instance = <span class="keyword">new</span> MyPlugn($<span class="keyword">this</span>, options);</div><div class="line">        <span class="comment">// 这里将首次实例化的instance对象缓存到$(this).data(myPlugn)中</span></div><div class="line">        $<span class="keyword">this</span>.data($.fn.myPlugn.info.name, instance);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 这里是对插件的一个优化</div><div class="line">       * 判断当传入的options参数为字符串类型时，表示的是要调用instance实例中的options方法。举个例子</div><div class="line">       * var test = $('.test').myPlugn();</div><div class="line">       * test.myPlugn('add');</div><div class="line">       * 这样的第二句代码就调用了instance.add()这个方法</div><div class="line">       * 这里还能够传入参数，比如 add 函数形式为： add(a,b)&#123; return a+b; &#125;</div><div class="line">       * 那么我们就把第二句代码改为 test.myPlugn('add',[1,2]) 即可</div><div class="line">       * 注意这里的第二个参数要求是一个数组，对应你要调用的那个函数的参数，比如上面的例子就如同调用了 instance.add(1,2)</div><div class="line">       */</div><div class="line">      <span class="keyword">typeof</span> options === <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> instance[options] === <span class="string">"function"</span> &amp;&amp; instance[options].apply(instance,paramArray);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * plugn infomation</div><div class="line">     * 这里可以添加一些插件的信息</div><div class="line">     * 如版本号，插件名等</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.info = &#123;</div><div class="line">    <span class="string">"version"</span> : <span class="string">"v1.0"</span>,</div><div class="line">    <span class="string">"name"</span> : <span class="string">"myPlugn"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * plugn default settings</div><div class="line">     * 这里可以配置插件的一些默认项</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.defaults = &#123;</div><div class="line">    <span class="comment">// default settings</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;)( jQuery );</div></pre></td></tr></table></figure><p>写到这里，我们就可以开始安心的去实现 MyPlugn 这个类了，将我们插件要实现的功能写在这个类里面就大功告成了。</p><p>下面贴上完整的jQuery-plugn.js 模板：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 这里先定义了我们要实现的MyPlugn类，以及在开发过程中需要用到的一些私有函数方法集合</span></div><div class="line">  <span class="keyword">var</span> MyPlugn, myPlugnPrivateMethod;</div><div class="line"></div><div class="line">  <span class="comment">// 这里使用立即执行的匿名函数来划分一个命名空间，避免干扰，在匿名函数内返回MyPlugn类</span></div><div class="line">  MyPlugn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数</div><div class="line">     * @author   dhb(dai_huibin@126.com)</div><div class="line">     * @date     2015-12-23</div><div class="line">     * @datetime 2015-12-23T11:12:00+0800</div><div class="line">         * @param       &#123;object|string&#125;     element   DOM object or selector</div><div class="line">         * @param       &#123;object&#125;           options   settings</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyPlugn</span>(<span class="params">element, options</span>)</span>&#123;</div><div class="line">      <span class="comment">// 构造函数内，将调用这儿插件函数的元素存下，并获取到一些插件配置的信息，执行初始化函数</span></div><div class="line">      <span class="keyword">this</span>.el = $(element);</div><div class="line">      <span class="keyword">this</span>.ops = $.extend(&#123;&#125;, $.fn.myPlugn.defaults, options);</div><div class="line">      <span class="keyword">this</span>.init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MyPlugn.prototype = &#123;</div><div class="line">      <span class="attr">init</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 这里是我们插件的一些初始化动作...</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a+b);</div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// ... 这里添加更多我们需要的函数，接口</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> MyPlugn;</div><div class="line">  &#125;)();</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * plugn 私有函数对象</div><div class="line">   * @type &#123;Object&#125;</div><div class="line">   */</div><div class="line">  myPlugnPrivateMethod = &#123;</div><div class="line">    <span class="comment">// 这里添加不希望被外界调用到的函数，只供 MyPlugn 使用</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 将 plugn 扩展到 $.fn</div><div class="line">     * @author   dhb(dai_huibin@126.com)</div><div class="line">     * @date     2015-12-23</div><div class="line">     * @datetime 2015-12-23T11:20:43+0800</div><div class="line">     * @param    &#123;object|string&#125;    options    setting options</div><div class="line">     * @param    &#123;array&#125;            paramArray 调用参数</div><div class="line">     * @return   &#123;object&#125;            return self</div><div class="line">     */</div><div class="line">  $.fn.myPlugn = <span class="function"><span class="keyword">function</span>(<span class="params">options, paramArray</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 我们在首次调用myPlugn的时候，实例化一个 MyPlugn 对象，并且将这个实例缓存在$(this).data(myPlugn)中</div><div class="line">       * 这样下次再调用myPlugn的时候，就不需要再实例化，只需要从$(this).data(myPlugn)中取出之前的实例进行操作即可</div><div class="line">       */</div><div class="line">      <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</div><div class="line">        instance = $<span class="keyword">this</span>.data($.fn.myPlugn.info.name);</div><div class="line"></div><div class="line">      <span class="comment">// 这里判断，如果已经存在instance，则表示已实例化过，就无需再实例化MyPlugn对象了</span></div><div class="line">      <span class="keyword">if</span>( !instance )&#123;</div><div class="line">        instance = <span class="keyword">new</span> MyPlugn($<span class="keyword">this</span>, options);</div><div class="line">        <span class="comment">// 这里将首次实例化的instance对象缓存到$(this).data(myPlugn)中</span></div><div class="line">        $<span class="keyword">this</span>.data($.fn.myPlugn.info.name, instance);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 这里是对插件的一个优化</div><div class="line">       * 判断当传入的options参数为字符串类型时，表示的是要调用instance实例中的options方法。举个例子</div><div class="line">       * var test = $('.test').myPlugn();</div><div class="line">       * test.myPlugn('add');</div><div class="line">       * 这样的第二句代码就调用了instance.add()这个方法</div><div class="line">       * 这里还能够传入参数，比如 add 函数形式为： add(a,b)&#123; return a+b; &#125;</div><div class="line">       * 那么我们就把第二句代码改为 test.myPlugn('add',[1,2]) 即可</div><div class="line">       * 注意这里的第二个参数要求是一个数组，对应你要调用的那个函数的参数，比如上面的例子就如同调用了 instance.add(1,2)</div><div class="line">       */</div><div class="line">      <span class="keyword">typeof</span> options === <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> instance[options] === <span class="string">"function"</span> &amp;&amp; instance[options].apply(instance,paramArray);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * plugn infomation</div><div class="line">     * 这里可以添加一些插件的信息</div><div class="line">     * 如版本号，插件名等</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.info = &#123;</div><div class="line">    <span class="string">"version"</span> : <span class="string">"v1.0"</span>,</div><div class="line">    <span class="string">"name"</span> : <span class="string">"myPlugn"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * plugn default settings</div><div class="line">     * 这里可以配置插件的一些默认项</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.defaults = &#123;</div><div class="line">    <span class="comment">// default settings</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;)( jQuery );</div></pre></td></tr></table></figure><p>到此jQuery插件的模板就完整了。</p><p>在使用Zepto开发插件时，用法与jQuery大同小异。在这份模板上最大的区别在于$(this).data() 函数的使用。</p><p>jQuery的data函数功能十分强大，能够缓存字符串，对象，函数等任何类型的数据，比如我们这边使用的时候将整个instance实例存在了$(this).data(‘myPlugn’) 中。这点在Zepto上就有所不同，Zepto的data函数相对来说就比较弱，只能存字符串变量，不能存储对象类型的变量，因此使用Zepto开发插件的时候，要想缓存实例的instance对象，需要做一个优化。下面贴上Zepto插件的模板，在data上缓存instance的细节不同罢了。</p><p>贴上Zepto-plugn.js 模板代码：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><div class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"> $ </span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 这里先定义了我们要实现的MyPlugn类，以及在开发过程中需要用到的一些私有函数方法集合</span></div><div class="line">  <span class="keyword">var</span> MyPlugn, myPlugnPrivateMethod;</div><div class="line"></div><div class="line">  <span class="comment">// 这里使用立即执行的匿名函数来划分一个命名空间，避免干扰，在匿名函数内返回MyPlugn类</span></div><div class="line">  MyPlugn = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 构造函数</div><div class="line">     * @author   dhb(dai_huibin@126.com)</div><div class="line">     * @date     2015-12-23</div><div class="line">     * @datetime 2015-12-23T11:12:00+0800</div><div class="line">         * @param       &#123;object|string&#125;     element   DOM object or selector</div><div class="line">         * @param       &#123;object&#125;           options   settings</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">MyPlugn</span>(<span class="params">element, options</span>)</span>&#123;</div><div class="line">      <span class="comment">// 构造函数内，将调用插件的元素存下，并获取到一些插件配置，执行初始化函数</span></div><div class="line">      <span class="keyword">this</span>.el = $(element);</div><div class="line">      <span class="keyword">this</span>.ops = $.extend(&#123;&#125;, $.fn.myPlugn.defaults, options);</div><div class="line">      <span class="keyword">this</span>.init();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    MyPlugn.prototype = &#123;</div><div class="line">      <span class="attr">init</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">// 这里是我们插件的一些初始化动作...</span></div><div class="line">      &#125;,</div><div class="line">      <span class="attr">add</span> : <span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(a+b);</div><div class="line">      &#125;,</div><div class="line">      <span class="comment">// ... 这里添加更多我们需要的函数，接口</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> MyPlugn;</div><div class="line">  &#125;)();</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">   * plugn 私有函数对象</div><div class="line">   * @type &#123;Object&#125;</div><div class="line">   */</div><div class="line">  myPlugnPrivateMethod = &#123;</div><div class="line">    <span class="comment">// 这里添加不希望被外界调用到的函数，只供 MyPlugn 使用</span></div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * 将 plugn 扩展到 $.fn</div><div class="line">     * @author   dhb(dai_huibin@126.com)</div><div class="line">     * @date     2015-12-23</div><div class="line">     * @datetime 2015-12-23T11:20:43+0800</div><div class="line">     * @param    &#123;object|string&#125;    options    setting options</div><div class="line">     * @param    &#123;array&#125;            paramArray 调用参数</div><div class="line">     * @return   &#123;object&#125;            return self</div><div class="line">     */</div><div class="line">  $.fn.myPlugn = <span class="function"><span class="keyword">function</span>(<span class="params">options, paramArray</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 我们在首次调用myPlugn的时候，实例化一个 MyPlugn 对象，并且将这个实例缓存在$(this).data(myPlugn)中</div><div class="line">       * 这样下次再调用myPlugn的时候，就不需要再实例化，只需要从$(this).data(myPlugn)中取出之前的实例进行操作即可</div><div class="line">       */</div><div class="line">      <span class="keyword">var</span> $<span class="keyword">this</span> = $(<span class="keyword">this</span>),</div><div class="line">        instance = $.fn.myPlugn.lookup[$<span class="keyword">this</span>.data($.fn.myPlugn.info.name)];</div><div class="line"></div><div class="line">      <span class="comment">// 这里判断，如果已经存在instance，则表示已实例化过，就无需再实例化MyPlugn对象了</span></div><div class="line">      <span class="keyword">if</span>( !instance )&#123;</div><div class="line">        instance = <span class="keyword">new</span> MyPlugn($<span class="keyword">this</span>, options);</div><div class="line">        <span class="comment">// 这里将首次实例化的instance对象缓存到$.myPlugn.lookup中，对应key值存入$(this).data(myPlugn)中</span></div><div class="line">        $.fn.myPlugn.lookup[++$.fn.myPlugn.lookup.i] = instance;</div><div class="line">        $<span class="keyword">this</span>.data($.fn.myPlugn.info.name,$.fn.myPlugn.lookup.i);</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">/**</span></div><div class="line">       * 这里是对插件的一个优化</div><div class="line">       * 判断当传入的options参数为字符串类型时，表示的是要调用instance实例中的options方法。举个例子</div><div class="line">       * var test = $('.test').myPlugn();</div><div class="line">       * test.myPlugn('add');</div><div class="line">       * 这样的第二句代码就调用了instance.add()这个方法</div><div class="line">       * 这里还能够传入参数，比如 add 函数形式为： add(a,b)&#123; return a+b; &#125;</div><div class="line">       * 那么我们就把第二句代码改为 test.myPlugn('add',[1,2]) 即可</div><div class="line">       * 注意这里的第二个参数要求是一个数组，对应你要调用的那个函数的参数，比如上面的例子就如同调用了 instance.add(1,2)</div><div class="line">       */</div><div class="line">      <span class="keyword">typeof</span> options === <span class="string">"string"</span> &amp;&amp; <span class="keyword">typeof</span> instance[options] === <span class="string">"function"</span> &amp;&amp; instance[options].apply(instance,paramArray);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * plugn infomation</div><div class="line">     * 这里可以添加一些插件的信息</div><div class="line">     * 如版本号，插件名等</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.info = &#123;</div><div class="line">    <span class="string">"version"</span> : <span class="string">"v1.0"</span>,</div><div class="line">    <span class="string">"name"</span> : <span class="string">"myPlugn"</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/**</span></div><div class="line">     * plugn instance</div><div class="line">     * i 为 MyPlugn 实例的计数</div><div class="line">     * 将instance实例存放在这个对象中</div><div class="line">     * 获取instance的key为 $(this).data('myPlugn') =&gt; instance</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.lookup = &#123;</div><div class="line">    <span class="attr">i</span> : <span class="number">0</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * plugn default settings</div><div class="line">     * 这里可以配置插件的一些默认项</div><div class="line">     * @type &#123;Object&#125;</div><div class="line">     */</div><div class="line">  $.fn.myPlugn.defaults = &#123;</div><div class="line">    <span class="comment">// default settings</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;)( Zepto );</div></pre></td></tr></table></figure></div><div></div><div></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/JS/" rel="tag">#JS</a> <a href="/tags/jquery/" rel="tag">#jquery</a> <a href="/tags/plugin/" rel="tag">#plugin</a> <a href="/tags/zepto/" rel="tag">#zepto</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/c744105d/" rel="next" title="计算机学院大学生程序设计竞赛 杭电ACM校赛"><i class="fa fa-chevron-left"></i> 计算机学院大学生程序设计竞赛 杭电ACM校赛</a></div><div class="post-nav-prev post-nav-item"> <a href="/posts/a254636/" rel="prev" title="HEXO+Github 搭建博客">HEXO+Github 搭建博客<i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="post-spread"></div></div></div><div class="comments" id="comments"><div onclick="ShowGitment()" id="gitment-display-button">Show comments from Gitment</div><div id="gitment-container" style="display:none"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span><span class="sidebar-toggle-line sidebar-toggle-line-middle"></span><span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap"> Table of Contents</li><li class="sidebar-nav-overview" data-target="site-overview"> Overview</li></ul><section class="site-overview sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" src="/images/avatar.png" alt="Koala.ink"><p class="site-author-name" itemprop="name">Koala.ink</p><p class="site-description motion-element" itemprop="description">Coding my future.</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"> <a href="/archives"><span class="site-state-item-count">34</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories"><span class="site-state-item-count">17</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags"><span class="site-state-item-count">36</span> <span class="site-state-item-name">tags</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/koalaink" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub</a></span></div></section><section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><p class="post-toc-empty">This post does not have a Table of Contents</p></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2015 - <span itemprop="copyrightYear">2018</span><span class="with-love"><i class="fa fa-fw fa-github"></i></span> <span class="author" itemprop="copyrightHolder"><a class="hosted-link" href="/">Koala.ink</a></span></div><div class="hosted-on"> Hosted on<a class="hosted-link" href="https://github.com/koalaink/koalaink.github.io"><i class="fa fa-fw fa-github"></i> GitHub</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script><script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script><script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script><script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script><script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script type="text/javascript">function ShowGitment(){document.getElementById("gitment-display-button").style.display="none",document.getElementById("gitment-container").style.display="block";var e=new Gitment({id:document.location.href,owner:"KoalaInk",repo:"koalaink.github.io",oauth:{client_id:"050fc13519ecf4c906f1",client_secret:"3089171e76120c5937013151ad8577141fde9141"}});e.render("gitment-container")}</script><script type="text/javascript">function proceedsearch(){$("body").append('<div class="popoverlay">').css("overflow","hidden"),$(".popup").toggle()}var isfetched=!1,search_path="search.xml";0==search_path.length&&(search_path="search.xml");var path="/"+search_path,searchFunc=function(e,t,a){"use strict";$.ajax({url:e,dataType:"xml",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var r=$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get(),c=document.getElementById(t),s=document.getElementById(a);c.addEventListener("input",function(){var e=0,t='<ul class="search-result-list">',a=this.value.trim().toLowerCase().split(/[\s\-]+/);s.innerHTML="",this.value.trim().length>1&&r.forEach(function(r){var c=!0,s=r.title.trim().toLowerCase(),n=r.content.trim().replace(/<[^>]+>/g,"").toLowerCase(),i=r.url,o=-1,l=-1,p=-1;if(""!=s&&""!=n&&a.forEach(function(e,t){o=s.indexOf(e),l=n.indexOf(e),o<0&&l<0?c=!1:(l<0&&(l=0),0==t&&(p=l))}),c){e+=1,t+="<li><a href='"+i+"' class='search-result-title'>"+s+"</a>";var h=r.content.trim().replace(/<[^>]+>/g,"");if(p>=0){var u=p-20,d=p+80;u<0&&(u=0),0==u&&(d=50),d>h.length&&(d=h.length);var f=h.substring(u,d);a.forEach(function(e){var t=new RegExp(e,"gi");f=f.replace(t,'<b class="search-keyword">'+e+"</b>")}),t+='<p class="search-result">'+f+"...</p>"}t+="</li>"}}),t+="</ul>",0==e&&(t='<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'),""==a&&(t='<div id="no-result"><i class="fa fa-search fa-5x" /></div>'),s.innerHTML=t}),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),0==isfetched?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(function(e){$(".popup").hide(),$(".popoverlay").remove(),$("body").css("overflow","")}),$(".popup").click(function(e){e.stopPropagation()})</script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script><script>AV.initialize("MAsnSi44NPvCiO2yaUFaS9xP-gzGzoHsz","KbDduhEI6reqUU4FFU5Jz1wk")</script><script>function showTime(e){var t=new AV.Query(e),n=[],o=$(".leancloud_visitors");o.each(function(){n.push($(this).attr("id").trim())}),t.containedIn("url",n),t.find().done(function(e){var t=".leancloud-visitors-count";if(0===e.length)return void o.find(t).text(0);for(var i=0;i<e.length;i++){var s=e[i],r=s.get("url"),c=s.get("time"),l=document.getElementById(r);$(l).find(t).text(c)}for(var i=0;i<n.length;i++){var r=n[i],l=document.getElementById(r),u=$(l).find(t);""==u.text()&&u.text(0)}}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(e,t){var n=$(".leancloud_visitors"),o=n.attr("id").trim(),i=n.attr("data-flag-title").trim(),s=new AV.Query(e);s.equalTo("url",o),s.find({success:function(t){if(t.length>0){var n=t[0];n.fetchWhenSave(!0),n.increment("time"),n.save(null,{success:function(e){var t=$(document.getElementById(o));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})}else{var s=new e,r=new AV.ACL;r.setPublicReadAccess(!0),r.setPublicWriteAccess(!0),s.setACL(r),s.set("title",i),s.set("url",o),s.set("time",1),s.save(null,{success:function(e){var t=$(document.getElementById(o));t.find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}})}},error:function(e){console.log("Error:"+e.code+" "+e.message)}});var r=new t,c=new AV.ACL;c.setPublicReadAccess(!0),c.setPublicWriteAccess(!0),r.setACL(c),r.set("title",i),r.set("url",o),r.set("time",1),r.save(null,{success:function(e){},error:function(e,t){console.log("Failed to create")}})}$(function(){var e=AV.Object.extend("Counter"),t=AV.Object.extend("History");1==$(".leancloud_visitors").length?addCount(e,t):$(".post-title-link").length>1&&showTime(e)})</script></body></html>